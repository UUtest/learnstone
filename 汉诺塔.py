def move(n, a, b, c):
    if n == 1:
        print (a, '->', c)
        return
    move(n - 1, a, c, b)
    move(1, a, b, c)
    move(n - 1, b, a, c)
'''
这个游戏的规律：
一、把a上面的除最大的那个，剩下的其他盘(n-1 个)移动到b;
二、然后把a最后一个最大的移动到c上;
三、然后再把b上的移动到c上：
把b上除最大的盘子，剩下的其他盘(n-1 个)移动到空的a上，然后把b最大的移动到c上;
......
每步化成代码：
move(n-1, a, c, b)
此函数是第一步中的a通过c把盘子放在b上

move(1, a, b, c)
当第一步把所有盘子都移动完后，需要移动最大的盘子到c上(执行函数第一步，n=1: a，'->', c)

move(n -1, b, a, c)
最后一步就是把b上的开始就被移动的n-1个盘子通过空的a，移动到c了。

把3个盘子的通过代码演示，按缩进原则，每一个缩进即进一个递归函数，
每打印一次即中止当前递归，也就是每个print说明：
1.n == 1,n不等于1时进入递归
2.看准每次函数参数的实参
move(3,'A','B','C')
#执行第一步：move(n - 1, a, c, b)
                          #把当前a('A')上面的盘子移动到c('B')再移动到b('C')
n = 3:
    n = n - 1 =2:
    move(2, 'A', 'C', 'B')
                          #n != 1,准备执行其第一个递归,从头执行move(n, a, b, c)
    n = n - 1 = 1:
        move(1,'A', 'B', 'C')
        print('A', '->', 'C')
                          #执行move(1, a, c, b)
                          #move(n -1, a, c,b)的第一个递归完成
                          #即移动最小的盘子从a('A')到c('C')上
                          #第一个递归结束
n =2:
        n = n - 1 = 1:
        move(1, 'A', 'C', 'B')
        n = 1:
        print('A','->', 'B')
                          #开始n不等于1，然后直接执行函数move(1, a, c, b)
                          #就是把a('A')上的第二个盘子放到b('B')上
n = 1:
        move(1,'C', 'A', 'B')
        print('C', '->', 'B') 
                          #此时直接执行move(1, a, b, c)
                          #即最后把c('C')上的盘子移到b('B')上
#进行第二步,把a('A')上的最大盘子放到c('C')上：
move(1, 'A', 'B', 'C')
    print('A','->', 'C')

#进行第三步,把b('B')上的盘子通过a('A')移动到c('C')上：
move(2, b, a, c )
n -1 = 2:
    move(2, 'B', 'A', 'C')
    n = 2-1 =1:
    move(1, 'B', 'C', 'A')
    print('B', '->', 'A')
n - 1 = 1:
    move(1, 'B', 'A', 'C')
    print('B','->', 'C')
n = 1:
    move(1, 'A', 'B', 'C')
    print('A', '->', 'C')
#汉诺塔移动完成
'''

